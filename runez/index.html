<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="UTF-8">
    <title>seh.dev</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description" content="" />

    <meta property="og:title" content="The Runez Compression Algorithms" />
    <meta property="og:description" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://seh.dev/runez/" />
    <meta itemprop="name" content="The Runez Compression Algorithms">
    <meta itemprop="description" content="">
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="The Runez Compression Algorithms"/>
    <meta name="twitter:description" content=""/>

    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32.png">

    
    <link rel="stylesheet" href="https://seh.dev/scss/style.min.c535b8bc90eb1287432762da2e2ef5fb3d2f9583e20de56032f1f77e3cbabe05.css" >
</head>
<body>
    <header>
    <div class="header header-frame">
        <div>
          
            <h1 class="header__title">The Runez Compression Algorithms</h1>
          
            
        </div>
        <nav class="header-nav">
            <ul class="header-nav-list header-nav-list--menu">
                
                
                    
                        <li class="header-nav-list__item">
                            <a class="header-nav-list__link" href="/about/">
                                
                                <span>About</span>
                            </a>
                        </li>
                    
                
            </ul>
            <button class="header-nav-list__nav-btn">navigation</button>
        </nav>
        <button class="mb-header__menu-btn">
            <span class="mb-header__menu-btn-line"></span>
            <span class="mb-header__menu-btn-line"></span>
            <span class="mb-header__menu-btn-line"></span>
        </button>
    </div>
    <nav id="mobile-header-nav" class="mb-header-nav">
  
  
  <button class="mb-header-nav__close-btn flex-center">
    <svg
            class="mb-header-nav__svg-icon"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            width="32"
            height="32"
            >
            <path
                d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
                />
            <path d="M0 0h24v24H0z" fill="none" />
        </svg>
    </button>
    
    <div class="mb-header-nav__wrapper">
        <div class="mb-header-nav__container">
            <svg
                width="240"
                height="72"
                viewBox="0 0 240 72"
                class="mb-header-nav__title"
                >
                <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle">
                Tags
                </text>
            </svg>
            <ul class="mb-header-nav-list">
                
                    
                        
                          <li class="mb-header-nav-list__item ">
                        <a class="mb-header-nav-list__link" href="https://seh.dev/tags/go/"
                                                            >go</a
                                                        >
                    </li>
                        
                    
                
            </ul>
        </div>
        <div class="mb-header-nav__container">
            <svg
                width="240"
                height="72"
                viewBox="0 0 240 72"
                class="mb-header-nav__title"
                >
                <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle">
                Menu
                </text>
            </svg>
            <ul class="mb-header-nav-list">
                
                
                    
                      <li class="mb-header-nav-list__item ">
                            <a class="mb-header-nav-list__link" href="/about/">
                                About
                            </a>
                        </li>
                    
                
            </ul>
        </div>
    </div>
</nav>

</header>



    <div id="content">
<article class="post">
  
    <div class="post-content"><!-- KateX stuff -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css" integrity="sha384-dbVIfZGuN1Yq7/1Ocstc1lUEm+AT+/rCkibIcC/OmWo5f0EA48Vf8CytHzGrSwbQ" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js" integrity="sha384-2BKqo+exmr9su6dir+qCw08N2ZKRucY4PrGQPPWU1A7FtlCGjmEGFqXCv5nyM5Ij" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
<!-- KateX stuff -->
<h1 id="the-runez-compression-algorithms">The Runez Compression Algorithms</h1>
<p>In January of 2020 I set about writing a pair of naïve, lossless, compression algorithms inspired by a series of conversations over coffee with a good friend.</p>
<p>These algorithms are very naïve, but simple structurally and to that end I will attempt to convey the implementation.</p>
<p>There are two algorithms, <a href="https://github.com/henesy/runez">runez</a> and <a href="https://github.com/henesy/runez2">runez2</a>.</p>
<p>The runez2 algorithm is a strictly superior successor  \(^ \dagger\)  to runez with the primary improvement being that there is no unique character limit, which will be explained later.</p>
<p>The name &lsquo;runez&rsquo; is inspired by the fact that this algorithm attempts to compress utf-8 characters, or, runes. The &lsquo;z&rsquo; implies the compression and looks cool ☺.</p>
<p>The standard archive suffix for runez is <code>.rz</code> and <code>.rz2</code> for runez2.</p>
<h2 id="usage">Usage</h2>
<p>The best exposition is one you can play with yourself, presuming you have <a href="https://golang.org">go</a> installed, you can play with the runez algorithms as follows using the <a href="https://github.com/henesy/runez2/blob/master/mac.txt">mac.txt</a> file found in the <a href="https://github.com/henesy/runez2">runez2 repository</a>.</p>
<p>The <a href="https://github.com/9fans/plan9port">plan9port</a> <a href="https://9fans.github.io/plan9port/man/man1/wc.html">wc(1)</a> is used as it supports the counting of valid utf-8 characters. The plan9port <code>wc</code> command is called explicitly using the plan9port <code>9</code> program to circumvent the standard <code>$PATH</code> calling convention.</p>
<p>The runez family tools operate using standard input and standard output and compress by default.</p>
<p>The runez family algorithms assume that they can read the entirety of their input file into memory.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ runez -h
Usage of runez:
  -D	Chatty debug mode
  -c	Explicit compress mode
  -d	De-compress mode
$
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ runez2 -h
Usage of runez2:
  -D	Chatty debug mode
  -c	Explicit compress mode
  -d	De-compress mode
$
</code></pre></div><h3 id="compression">Compression</h3>
<p><strong>Runez:</strong></p>
<p>Note the deliberate truncation of the larger mac.txt from the runez2 repository.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ sed 5q mac.txt | runez &gt; mac.rz
$ sed 5q mac.txt | <span style="color:#099">9</span> wc -r
    <span style="color:#099">195</span>
$ <span style="color:#099">9</span> wc -c mac.rz mac.txt
    <span style="color:#099">290</span> mac.rz
   <span style="color:#099">3550</span> mac.txt
   <span style="color:#099">3840</span> total
$
</code></pre></div><p>What happens if you don&rsquo;t truncate the file?</p>
<p><strong>Runez2:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ runez2 &lt; mac.txt &gt; mac.rz2
$ <span style="color:#099">9</span> wc -r mac.txt
   <span style="color:#099">1950</span> mac.txt
$ <span style="color:#099">9</span> wc -c mac.txt mac.rz2
   <span style="color:#099">3550</span> mac.txt
   <span style="color:#099">2030</span> mac.rz2
   <span style="color:#099">5580</span> total
$
</code></pre></div><h3 id="decompression">Decompression</h3>
<p><strong>Runez:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ runez -d &lt; mac.rz
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
$
</code></pre></div><p><strong>Runez2:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ runez2 -d &lt; mac.rz2
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
Моето летачко возило е полно со јагули
$
</code></pre></div><h2 id="runez-the-first">Runez the first</h2>
<h3 id="design">Design</h3>
<p>Specification: <a href="https://github.com/henesy/runez/blob/master/spec.md">https://github.com/henesy/runez/blob/master/spec.md</a></p>
<p>Runez takes a series of valid utf-8 characters, which permits the ASCII range, and compacts them into a little-endian binary archive file.</p>
<p>The file consists of a table where each row encodes information about one rune, a valid utf-8 character.</p>
<p>A row takes the form of at least 3 columns:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">[number of position : uint8] [rune : int32] [position : uint8 …]
</code></pre></div><p>Note that the ellipses &lsquo;…&rsquo; implies that there can be be multiple positions, or offsets, a rune can occupy within a file.</p>
<p>For example, given the string:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">αβξαβξ
</code></pre></div><p>The table would resemble:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">2 α 0 3
2 β 1 4
2 ξ 2 5
</code></pre></div><p>If we perform a small calculation we can see that the size of the input file is 6 int32 values, which are a total of  \( 4 * 6 = 24\)  bytes. The output file is 3 int32 values and 9 uint8 values totalling  \( 3 * 4 + 9 = 21 \)  bytes. In total, this input yields 3 bytes of compression.</p>
<p>The fatal assumption made by runez is that there are no more than  \( (\oplus uint8(0) = 255)+1 = 256 \)  total runes present in the input file.</p>
<p>This implies that runez can only compress files consisting of 256 characters or less, which is not very useful.</p>
<p>The following function expresses the size of the final archive size ( \(\sigma\) ) in bytes:</p>
<p>$$
\sigma = \sum \forall r{1 + 4 + n_r}
$$</p>
<p>We can apply this formula on the mac.txt example from earlier to calculate the size of the final archive.</p>
<p>The file consists of one line of 39 runes repeated across 5 lines:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Моето летачко возило е полно со јагули\n
</code></pre></div><p>The set of 19 unique runes:</p>
<p>$$
r \isin R{nl, ␣, М, о, е, т, л, а, ч, к, в, з, и, п, с, ј, г, у, н}
$$</p>
<p>$$
R \implies bookkeeping_\sigma = (1 + 4) * 19 = 95\ bytes
$$</p>
<p>$$
positions_\sigma = 5 * 39 = 195
$$</p>
<p>$$
\sigma = bookkeeping_\sigma + positions_\sigma = 95 + 195 = 290
$$</p>
<p>$$
\therefore 290\ bytes
$$</p>
<p>We can validate this manually:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ wc -c mac.rz
<span style="color:#099">290</span> mac.rz
$
</code></pre></div><p>The space savings shown here is  \( 1- \frac{290}{355} = 0.18 = 18\% \) .</p>
<h3 id="implementation">Implementation</h3>
<h4 id="compression-1">Compression</h4>
<p>Function definition: <a href="https://github.com/henesy/runez/blob/30368d63a423af444da1017f5317482222e9a713/main.go#L57">https://github.com/henesy/runez/blob/30368d63a423af444da1017f5317482222e9a713/main.go#L57</a></p>
<p>Runez begins compression by building a hashmap, mapping a <code>rune</code> to a list of <code>uint8</code>&rsquo;s.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">dict <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>(<span style="color:#000;font-weight:bold">map</span>[<span style="color:#458;font-weight:bold">rune</span>]<span style="color:#000;font-weight:bold">*</span>list.List)
</code></pre></div><p>Each rune from the input file is then iterated on sequentially, with their offset from the beginning of the file, starting at 0, being indexed as <code>i</code>.</p>
<p>Each rune found will be checked for presence within the map.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">if</span> dict[r] <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> {
	dict[r] = list.<span style="color:#900;font-weight:bold">New</span>()
}
</code></pre></div><p>If the rune is found in the map as existing, the current rune offset is prepended to the list for said rune.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">dict[r].<span style="color:#900;font-weight:bold">PushFront</span>(<span style="color:#0086b3">uint8</span>(i))
</code></pre></div><p>If the rune is not found in the map, a list is allocated for the rune and the current rune offset is prepended to the list for said rune.</p>
<p>After all the runes have been read from the input file, the map is then iterated over and rows are generated for the output table.</p>
<p>The number of positions is derived from the list length.</p>
<p>The rune is derived from the map key during iteration.</p>
<p>The positions are extracted starting from the front of the list.</p>
<p>We can see the relevant encoding of the position count, rune, and positions respectively as per:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">err <span style="color:#000;font-weight:bold">:=</span> binary.<span style="color:#900;font-weight:bold">Write</span>(w, binary.LittleEndian, pc)
<span style="color:#a61717;background-color:#e3d2d2">…</span>
err = binary.<span style="color:#900;font-weight:bold">Write</span>(w, binary.LittleEndian, r)
<span style="color:#a61717;background-color:#e3d2d2">…</span>
<span style="color:#000;font-weight:bold">for</span> p <span style="color:#000;font-weight:bold">:=</span> l.<span style="color:#900;font-weight:bold">Front</span>(); p <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span>; p = p.<span style="color:#900;font-weight:bold">Next</span>() {
	err <span style="color:#000;font-weight:bold">:=</span> binary.<span style="color:#900;font-weight:bold">Write</span>(w, binary.LittleEndian, <span style="color:#0086b3">byte</span>(p.Value.(<span style="color:#458;font-weight:bold">uint8</span>)))
	<span style="color:#a61717;background-color:#e3d2d2">…</span>
}
</code></pre></div><h4 id="decompression-1">Decompression</h4>
<p>Function definition: <a href="https://github.com/henesy/runez/blob/30368d63a423af444da1017f5317482222e9a713/main.go#L116">https://github.com/henesy/runez/blob/30368d63a423af444da1017f5317482222e9a713/main.go#L116</a></p>
<p>Runez begins decompression by allocated a hashmap mapping a <code>rune</code> to a slice of <code>uint8</code>&rsquo;s.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">dict <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>(<span style="color:#000;font-weight:bold">map</span>[<span style="color:#458;font-weight:bold">rune</span>][]<span style="color:#458;font-weight:bold">uint8</span>)
</code></pre></div><p>Runez will read from the input file until EOF is reached.</p>
<p>Each iteration of the reading process will extract a position count, rune, and a number of positions as defined by the position count.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">err <span style="color:#000;font-weight:bold">:=</span> binary.<span style="color:#900;font-weight:bold">Read</span>(r, binary.LittleEndian, <span style="color:#000;font-weight:bold">&amp;</span>pc)
<span style="color:#a61717;background-color:#e3d2d2">…</span>
err = binary.<span style="color:#900;font-weight:bold">Read</span>(r, binary.LittleEndian, <span style="color:#000;font-weight:bold">&amp;</span>ru)
<span style="color:#a61717;background-color:#e3d2d2">…</span>
<span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">uint8</span>(<span style="color:#099">0</span>); i &lt; pc; i<span style="color:#000;font-weight:bold">++</span> {
	<span style="color:#000;font-weight:bold">var</span> p <span style="color:#458;font-weight:bold">uint8</span>

	err = binary.<span style="color:#900;font-weight:bold">Read</span>(r, binary.LittleEndian, <span style="color:#000;font-weight:bold">&amp;</span>p)
	<span style="color:#a61717;background-color:#e3d2d2">…</span>

	dict[ru][i] = p
}
<span style="color:#a61717;background-color:#e3d2d2">…</span>
</code></pre></div><p>The total number of runes based on the sum of position counts is stored for later use.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">sum <span style="color:#000;font-weight:bold">:=</span> <span style="color:#099">0</span>
<span style="color:#a61717;background-color:#e3d2d2">…</span>
sum <span style="color:#000;font-weight:bold">+=</span> <span style="color:#0086b3">int</span>(pc)
<span style="color:#a61717;background-color:#e3d2d2">…</span>
</code></pre></div><p>The slice is allocated in size of &lsquo;position count&rsquo; number of positions.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">dict[ru] = <span style="color:#0086b3">make</span>([]<span style="color:#458;font-weight:bold">uint8</span>, pc)
</code></pre></div><p>After all runes have been read, the map is iterated over and inside said iteration, the slice of positions is iterated over.</p>
<p>A <code>Pair</code> type is used to conjoin a rune to a given position.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">type</span> Pair <span style="color:#000;font-weight:bold">struct</span> {
	R <span style="color:#458;font-weight:bold">rune</span>
	P <span style="color:#458;font-weight:bold">uint8</span>
}
</code></pre></div><p>A slice of pairs is allocated proportional to the size of the aforementioned sum value.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">master <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>([]Pair, <span style="color:#099">0</span>, sum)
</code></pre></div><p>Each position iterated over is placed in a <code>Pair</code> with its parent rune and the couple is appended to the master slice of pairs.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">for</span> ru, s <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">range</span> dict {
	<span style="color:#000;font-weight:bold">for</span> _, p <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">range</span> s {
		master = <span style="color:#0086b3">append</span>(master, Pair{ru, p})
	}
}
</code></pre></div><p>After all position and rune pairs have been processed, the slice of all pairs is sorted by position value, starting from 0.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a61717;background-color:#e3d2d2">…</span>
<span style="color:#000;font-weight:bold">type</span> ByPosition []Pair

<span style="color:#000;font-weight:bold">func</span> (a ByPosition) <span style="color:#900;font-weight:bold">Len</span>() <span style="color:#458;font-weight:bold">int</span>           { <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">len</span>(a) }
<span style="color:#000;font-weight:bold">func</span> (a ByPosition) <span style="color:#900;font-weight:bold">Swap</span>(i, j <span style="color:#458;font-weight:bold">int</span>)      { a[i], a[j] = a[j], a[i] }
<span style="color:#000;font-weight:bold">func</span> (a ByPosition) <span style="color:#900;font-weight:bold">Less</span>(i, j <span style="color:#458;font-weight:bold">int</span>) <span style="color:#458;font-weight:bold">bool</span> { <span style="color:#000;font-weight:bold">return</span> a[i].P &lt; a[j].P }
<span style="color:#a61717;background-color:#e3d2d2">…</span>
sort.<span style="color:#900;font-weight:bold">Sort</span>(<span style="color:#900;font-weight:bold">ByPosition</span>(master))
<span style="color:#a61717;background-color:#e3d2d2">…</span>
</code></pre></div><p>The sorted slice of pairs is then emitted to standard output.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">for</span> _, pair <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">range</span> master {
	w.<span style="color:#900;font-weight:bold">Write</span>([]<span style="color:#0086b3">byte</span>(<span style="color:#0086b3">string</span>(pair.R)))
}
</code></pre></div><h2 id="runez-the-second">Runez the second</h2>
<p>Specification: <a href="https://github.com/henesy/runez2/blob/master/spec.md">https://github.com/henesy/runez2/blob/master/spec.md</a></p>
<h3 id="design-1">Design</h3>
<p>Runez2 takes a series of valid utf-8 characters, which permits the ASCII range, and compacts them into a little-endian binary archive file.</p>
<p>The file consists of two parts, a preamble which lists all the unique runes in a specific order and a body which is separated from the preamble by a null rune and consists of single byte (<code>uint8</code>) values indicating the unique rune which should be substituted into position for said single byte value.</p>
<p>The archive format is thus structured as follows:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">[rune : int32]
…
[\0 : int32]
[N : uint8]
</code></pre></div><p>Note that the ellipses &lsquo;…&rsquo; implies that there can be many runes prior to the null divider.</p>
<p>For example, given the string:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">αβξαβξ
</code></pre></div><p>The file would resemble:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">αβξ
\0
0 1 2 0 1 2
</code></pre></div><p>The core assumptions made by Runez2 is that the whole file can be read into memory and that there are no more than  \( (\oplus uint8(0) = 255)+1 = 256 \)  <strong>unique</strong> runes.</p>
<p>Additionally, files compressed by runez2 cannot contain null runes (<code>\0</code>) as this is reserved as the dividing point for the preamble.</p>
<p>There is an implied maximum compression ratio offered by runez2.</p>
<p>The following function expresses the size of the final archive size ( \(\sigma\) ) in bytes:</p>
<p>$$
\sigma = 4 + \sum \forall r{n_r + 4 , r \neq \empty}
$$</p>
<p>Note that the function for finding the maximum potential size in bytes of the plaintext utf-8 is:</p>
<p>$$
\sigma = \sum \forall r { n_r * 4 }
$$</p>
<p>Note that in practice, due to how utf-8 text encoding works, the size in bytes of the plaintext is most likely much smaller than this number.</p>
<p>We can apply the former formula on the mac.txt example from earlier to calculate the size of the final archive.</p>
<p>The file consists of one line of 39 runes repeated many times:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Моето летачко возило е полно со јагули\n
</code></pre></div><p>The set of 19 unique runes:</p>
<p>$$
r \isin R{nl, ␣, М, о, е, т, л, а, ч, к, в, з, и, п, с, ј, г, у, н}
$$</p>
<p>$$
R \implies preamble_\sigma = 4 + (4 * 19) = 80\ bytes
$$</p>
<p>$$
body_\sigma = lines_n * linerunes_n = 50 * 39 = 2030\ bytes
$$</p>
<p>$$
\sigma = preamble_\sigma + body_\sigma
$$</p>
<p>$$
\therefore 2030\ bytes
$$</p>
<p>We can validate this manually:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ wc -c mac.rz2
<span style="color:#099">2030</span> mac.rz2
$
</code></pre></div><p>The space savings shown here is  \( 1- \frac{2030}{3550} = 0.43 = 43\% \) .</p>
<p>This ratio is indicative of the maximum space savings of this algorithm as illustrated by compressing a much larger document, a utf-8 text transcription of the Quran:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ wc -c quran.txt
<span style="color:#099">1344086</span> quran.txt
$ runez2 &lt; quran.txt &gt; quran.rz2
$ wc -c quran.rz2
<span style="color:#099">733387</span> quran.rz2
$
</code></pre></div><p>The space savings shown is  \( 1- \frac{733387}{1344086} = 0.45 = 45\% \) . I do not believe that the ratio improves significantly beyond this point.</p>
<p><strong>Disclaimer:</strong> I am not a mathematician, these formulae are an approximation of what I remember from university ☺.</p>
<p>The assumptions make runez2 insufficient for languages such as Mandarin in applications which possess a number of distinct runes greater than 256, which is most applications in my experience, but is sufficient in all applications for alphabets such as Arabic, Cyrillic, etc.</p>
<h3 id="implementation-1">Implementation</h3>
<h4 id="compression-2">Compression</h4>
<p>Function definition: <a href="https://github.com/henesy/runez2/blob/98adfdfacd54c540751e4062e581143576e5344a/main.go#L80">https://github.com/henesy/runez2/blob/98adfdfacd54c540751e4062e581143576e5344a/main.go#L80</a></p>
<p>Runez2 begins by beginning a hashmap, mapping a <code>rune</code> to a <code>uint8</code>.</p>
<p>The <code>uint8</code> mapped value is the indexed offset of a given <code>rune</code> in the order the runes were found, and will be emitted.</p>
<p>A list is made to push the rune index values into to represent the structure of the text where each rune index value is a shorthand reference to the rune that should occupy the index values.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">dict <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>(<span style="color:#000;font-weight:bold">map</span>[<span style="color:#458;font-weight:bold">rune</span>]<span style="color:#458;font-weight:bold">uint8</span>)
runes <span style="color:#000;font-weight:bold">:=</span> list.<span style="color:#900;font-weight:bold">New</span>()
</code></pre></div><p>As runes are found from the input file they are added into the map and pushed, in order, into the list.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">if</span> i <span style="color:#000;font-weight:bold">&lt;=</span> <span style="color:#099">0</span> {
	<span style="color:#998;font-style:italic">// Handle the base case explicitly
</span><span style="color:#998;font-style:italic"></span>	dict[ru] = <span style="color:#0086b3">uint8</span>(i)
	i<span style="color:#000;font-weight:bold">++</span>
	first = ru
} <span style="color:#000;font-weight:bold">else</span> {
	<span style="color:#998;font-style:italic">// 0 means the rune isn&#39;t indexed - kind of a hack
</span><span style="color:#998;font-style:italic"></span>	<span style="color:#000;font-weight:bold">if</span> dict[ru] <span style="color:#000;font-weight:bold">&lt;=</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> ru <span style="color:#000;font-weight:bold">!=</span> first {
		dict[ru] = <span style="color:#0086b3">uint8</span>(i)
		i<span style="color:#000;font-weight:bold">++</span>
	}
}

<span style="color:#998;font-style:italic">// Push the i-value for the rune
</span><span style="color:#998;font-style:italic"></span>runes.<span style="color:#900;font-weight:bold">PushBack</span>(dict[ru])
</code></pre></div><p>When all the runes have been read, a slice is allocated to store a table of runes, the map is effectively reversed and the relevant <code>i</code>&lsquo;th position for a rune is where the rune from the map is stored.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">for</span> ru, i <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">range</span> dict {
	<span style="color:#a61717;background-color:#e3d2d2">…</span>
	table[i] = ru
}
</code></pre></div><p>The table is then iterated over and the runes are emitted in order from the table as the preamble of the archive.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">:=</span> <span style="color:#099">0</span>; i &lt; <span style="color:#0086b3">len</span>(table); i<span style="color:#000;font-weight:bold">++</span> {
	<span style="color:#a61717;background-color:#e3d2d2">…</span>
	err <span style="color:#000;font-weight:bold">:=</span> binary.<span style="color:#900;font-weight:bold">Write</span>(w, binary.LittleEndian, table[i])
	<span style="color:#a61717;background-color:#e3d2d2">…</span>
}
</code></pre></div><p>The preamble is terminated with a full null rune.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">err <span style="color:#000;font-weight:bold">:=</span> binary.<span style="color:#900;font-weight:bold">Write</span>(w, binary.LittleEndian, <span style="color:#0086b3">rune</span>(<span style="color:#099">0</span>))
</code></pre></div><p>The list of rune index values is then iterated over to emit the body of the document.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">for</span> p <span style="color:#000;font-weight:bold">:=</span> runes.<span style="color:#900;font-weight:bold">Front</span>(); p <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span>; p = p.<span style="color:#900;font-weight:bold">Next</span>() {
	err <span style="color:#000;font-weight:bold">:=</span> binary.<span style="color:#900;font-weight:bold">Write</span>(w, binary.LittleEndian, <span style="color:#0086b3">byte</span>(p.Value.(<span style="color:#458;font-weight:bold">uint8</span>)))
	<span style="color:#a61717;background-color:#e3d2d2">…</span>
}
</code></pre></div><h4 id="decompression-2">Decompression</h4>
<p>Function definition: <a href="https://github.com/henesy/runez2/blob/98adfdfacd54c540751e4062e581143576e5344a/main.go#L161">https://github.com/henesy/runez2/blob/98adfdfacd54c540751e4062e581143576e5344a/main.go#L161</a></p>
<p>A table is allocated to store the preamble runes read in from the input file.</p>
<p>The table is allocated with a maximum capacity of  \( (\oplus uint8(0) = 255)+1 = 256 \)  runes.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">var</span> table []<span style="color:#458;font-weight:bold">rune</span>

table = <span style="color:#0086b3">make</span>([]<span style="color:#458;font-weight:bold">rune</span>, <span style="color:#099">0</span>, <span style="color:#0086b3">int</span>(^<span style="color:#0086b3">uint8</span>(<span style="color:#099">0</span>)))
</code></pre></div><p>The preamble of runes are then read in and stored in order. Upon reaching a null rune, the preamble is terminated.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">for</span> {
	<span style="color:#000;font-weight:bold">var</span> ru <span style="color:#458;font-weight:bold">rune</span>

	err <span style="color:#000;font-weight:bold">:=</span> binary.<span style="color:#900;font-weight:bold">Read</span>(r, binary.LittleEndian, <span style="color:#000;font-weight:bold">&amp;</span>ru)
	<span style="color:#a61717;background-color:#e3d2d2">…</span>

	<span style="color:#000;font-weight:bold">if</span> ru <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span> {
		<span style="color:#a61717;background-color:#e3d2d2">…</span>
		<span style="color:#000;font-weight:bold">break</span>
	}

	table = <span style="color:#0086b3">append</span>(table, ru)
}
</code></pre></div><p>The indices are then read from the body of the archive, in order, and the rune value for the relevant index is substituted to restore the original content of the input, which is emitted.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">for</span> {
		<span style="color:#000;font-weight:bold">var</span> i <span style="color:#458;font-weight:bold">uint8</span>

		err <span style="color:#000;font-weight:bold">:=</span> binary.<span style="color:#900;font-weight:bold">Read</span>(r, binary.LittleEndian, <span style="color:#000;font-weight:bold">&amp;</span>i)
		<span style="color:#a61717;background-color:#e3d2d2">…</span>
		w.<span style="color:#900;font-weight:bold">Write</span>([]<span style="color:#0086b3">byte</span>(<span style="color:#0086b3">string</span>(table[i])))
}
</code></pre></div><h2 id="conclusions">Conclusions</h2>
<p>These algorithms were very fun to talk about and write in a casual manner, but are hardly sufficient for any serious compression use and consciously ignore more optimal programming patterns.</p>
<p>The most valuable take-away from the runez algorithms is that they are simple to implement, reason about, and illustrate a method of compression which may prove valuable for educational purposes, I hope ☺.</p>
<p>I&rsquo;m sure someone has already thought of these methods since they&rsquo;re so simple, but I haven&rsquo;t stumbled across these storage formats yet in the wild. Feel free to let me know so I can cite the originals for further reading!</p>
<h2 id="source">Source</h2>
<ul>
<li><a href="https://github.com/henesy/runez">https://github.com/henesy/runez</a></li>
<li><a href="https://github.com/henesy/runez2">https://github.com/henesy/runez2</a></li>
</ul>
<p> \(^ \dagger\)  — unless you want null runes.</p>
</div>
  
</article>
<button class="floating-button">
    <a class="floating-button__link" href="https://seh.dev/">
        <span>home</span>
    </a>
</button>


    </div>
    
    <footer class="post-footer">
    <div class="footer">
        
            <div>© 2020, Sean Hinchee</div>
        
        <div class="footer__socials">










</div>
    </div>
</footer>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>




    
    
      
<script src="https://seh.dev/js/script.js"></script>

    
  </body>
</html>
