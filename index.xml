<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>seh.dev</title>
    <link>https://seh.dev/</link>
    <description>Recent content on seh.dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2022, Sean Hinchee</copyright>
    <lastBuildDate>Sat, 18 Jun 2022 00:00:00 +0000</lastBuildDate>
    
  <atom:link href="https://seh.dev/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go Patterns - Fanning</title>
      <link>https://seh.dev/concy0/</link>
      <pubDate>Sat, 18 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://seh.dev/concy0/</guid>
      <description>Go Patterns - Fanning Background The summer of 2022 I had the chance to explain Go programming patterns I - and I assume others - use regularly in writing concurrent systems to my three interns.
Although many university courses will talk about threading, they do not necessarily discuss concurrency, rarely if ever Go, and rarely go in depth on polymorphism.
The state of affairs is unfortunate, because it means that although Go and plenty of other &amp;lsquo;current generation&amp;rsquo; programming languages have been publicly available for years, Go since at least 2012, the situation in many computer science programs is not very different from the state of affairs ten years ago.</description>
	  <mp3></mp3>
	  <youtube_id></youtube_id>
    </item>
    
    <item>
      <title>Writing UTF-8 Programs in Plan 9</title>
      <link>https://seh.dev/9runes/</link>
      <pubDate>Fri, 25 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://seh.dev/9runes/</guid>
      <description>Writing UTF-8 Programs in Plan 9 This post was written using 9front/amd64 “COMMUNITY VS INFRASTRUCTURE” as a reference.
Programs are built on Plan 9 using the 2c(1) compiler suite.
Thus, on amd64:
tenshi% 6c rsize.c tenshi% 6l rsize.6 tenshi% 6.out わ 4 4 tenshi% Remember, in C, a char (ASCII character) is almost always 1 byte (8 bits).
This document presumes that a non-rune char is 1 byte.
Initial reading  C Programming in Plan 9  UTF-8 in Plan 9 Plan 9 is full of UTF-8 aware programs, which makes sense, given that Plan 9 was the system UTF-8 was designed on/for.</description>
	  <mp3></mp3>
	  <youtube_id></youtube_id>
    </item>
    
    <item>
      <title>Creating and Applying 9front Patches (Git Edition)</title>
      <link>https://seh.dev/patches-git/</link>
      <pubDate>Tue, 24 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://seh.dev/patches-git/</guid>
      <description>Creating and Applying 9front Patches (Git Edition) History   October 2018, Ori pushes the first commit to git9.
  April 2019, Ori starts the 9fans thread &#39;[9fans] Git/fs: Possibly Usable&#39;.
  Late April 2019, Lufia announces their port of unix git on 9fans thread &#39;[9fans] Git client&#39;.
  June 2019, git9 migrates to git.
  July 2020, Atlassian deletes all Mercurial repositories without archive or remorse.</description>
	  <mp3></mp3>
	  <youtube_id></youtube_id>
    </item>
    
    <item>
      <title>Limbo GUI&#39;s with Tk</title>
      <link>https://seh.dev/limbo-gui/</link>
      <pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://seh.dev/limbo-gui/</guid>
      <description>Limbo GUI&amp;rsquo;s with Tk Motivation GUI programming can be very difficult and documentation for writing graphical programs can be provided with a large number of assumption on pre-existing knowledge, etc.
Additionally, compartmentalized examples which do not employ some kind of `other tricks&#39; can be hard to come by. This problem is exasperated for less well-known systems such as Inferno.
The first version of the second program shown below was written over a year ago, but did not work well and presented only the most minimal fulfillment of what could be called a functioning graphical program.</description>
	  <mp3></mp3>
	  <youtube_id></youtube_id>
    </item>
    
    <item>
      <title>Polymorphism in Limbo and Go 2</title>
      <link>https://seh.dev/limbgo/</link>
      <pubDate>Tue, 29 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://seh.dev/limbgo/</guid>
      <description>Polymorphism in Limbo and Go 2 Motivation Go has recently announced that it will be receiving a form of polymorphism through generics in Go 2.
Prior to and influencing Go (and thus Go 2), the Limbo programming language from the Inferno operating system had implemented a somewhat similar syntax for polymorphism.
There are very tangible and crucial differences, but for novelty the two languages are cross-referenced.
This post was primarily motivated by a discussion and linguistic adventure that occurred during a stream exploring the Limbo language and Inferno OS.</description>
	  <mp3></mp3>
	  <youtube_id></youtube_id>
    </item>
    
    <item>
      <title>Program development in Limbo</title>
      <link>https://seh.dev/limbo-intro/</link>
      <pubDate>Wed, 02 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://seh.dev/limbo-intro/</guid>
      <description>Program development in Limbo Motivation Resources covering software development under Inferno are fairly scarce.
As such, this post aims to provide a start-to-finish demonstration of program development in Limbo inside Inferno.
Introduction This post assumes you&amp;rsquo;re using Inferno, specifically purgatorio, hosted under linux/amd64 or similar.
It&amp;rsquo;s also possible to use Inferno under Docker as per the INSTALL file.
Other platforms are supported, but steps may differ here or there.
The rune $ indicates a unix shell command under bash, probably.</description>
	  <mp3></mp3>
	  <youtube_id></youtube_id>
    </item>
    
    <item>
      <title>The Runez Compression Algorithms</title>
      <link>https://seh.dev/runez/</link>
      <pubDate>Fri, 03 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://seh.dev/runez/</guid>
      <description>The Runez Compression Algorithms In January of 2020 I set about writing a pair of naïve, lossless, compression algorithms inspired by a series of conversations over coffee with a good friend.
These algorithms are very naïve, but simple structurally and to that end I will attempt to convey the implementation.
There are two algorithms, runez and runez2.
The runez2 algorithm is a strictly superior successor \(^ \dagger\) to runez with the primary improvement being that there is no unique character limit, which will be explained later.</description>
	  <mp3></mp3>
	  <youtube_id></youtube_id>
    </item>
    
    <item>
      <title>Go&#39;s History in Code</title>
      <link>https://seh.dev/go-legacy/</link>
      <pubDate>Sat, 20 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://seh.dev/go-legacy/</guid>
      <description>Go&amp;rsquo;s History in Code This post intends to showcase programming patterns, or stuff, which is common between Newsqueak, Alef, Plan9 C, Limbo, and Go.
All of these code snippets should be complete as shown and compilable/runnable in the state presented. The Alef examples might have subtle typos, but this is due to the fact I had to manually re-type them out from VirtualBox since I didn&amp;rsquo;t have copy/paste available to the guest.</description>
	  <mp3></mp3>
	  <youtube_id></youtube_id>
    </item>
    
    <item>
      <title>Porting Unix Software to Plan9</title>
      <link>https://seh.dev/porting/</link>
      <pubDate>Sat, 01 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://seh.dev/porting/</guid>
      <description>Porting Unix Software to Plan9 The original source code used in this port: https://github.com/rswier/c4.
The final port source code for the port: https://github.com/henesy/c4.
The commits for the port starting from my history should vaguely reflect the order and rough increment of changes described in this post. It is recommended to skim the source and changes while reading ☺.
Initial reading  C Programming in Plan 9  Porting This post will show the process of porting a unix program, c4, to plan9.</description>
	  <mp3></mp3>
	  <youtube_id></youtube_id>
    </item>
    
    <item>
      <title>Playing with Oberon in 2019</title>
      <link>https://seh.dev/oberon/</link>
      <pubDate>Sun, 01 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://seh.dev/oberon/</guid>
      <description>Playing with Oberon in 2019 Oberon is the name for an operating system and language pair written by Niklaus Wirth.
Oberon is notable for being simple and powerful in a manner which permits Oberon to be pleasant for use with education.
Refer to Wikipedia for some history and exposition: https://en.wikipedia.org/wiki/Oberon_(operating_system)
Getting Oberon The easiest way to get Oberon up and running from unix is through pdewacht&amp;rsquo;s risc emu: https://github.com/pdewacht/oberon-risc-emu
You can also, from unix, use A2 Oberon Subsystem for Unix (aosunix).</description>
	  <mp3></mp3>
	  <youtube_id></youtube_id>
    </item>
    
    <item>
      <title>Using p9sk1 authentication in modern 9front</title>
      <link>https://seh.dev/p9sk1/</link>
      <pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://seh.dev/p9sk1/</guid>
      <description>Using p9sk1 authentication in modern 9front Many moons ago 9front moved to dp9ik auth from p9sk1 due to security concerns. However, there may be cases, such as using parts of plan9port, that one may want to enable the old cpu protocol and p9sk1 authentication.
Steps to complete:
 Enable p9sk1 by removing the -N flag from the authsrv(2) init scripts:  /rc/bin/service.auth/authsrv.il566 /rc/bin/service.auth/tcp567   Enable the legacy cpu(1) protocol server via:  mv &#39;/rc/bin/service/!</description>
	  <mp3></mp3>
	  <youtube_id></youtube_id>
    </item>
    
    <item>
      <title>Intro to Graphics on Plan 9</title>
      <link>https://seh.dev/graphics/</link>
      <pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://seh.dev/graphics/</guid>
      <description>Intro to Graphics on Plan 9 A common question asked all over the Plan 9 community is that of how to get started making GUI applications, as 9 is closely married to the GUI.
While I might get around to a step by step tutorial on GUI programming in another post or location, I&amp;rsquo;d rather compile some helpful examples and resources for getting started.
Some useful programs for reference:
 9pong 9clock lines squares bouncing ball example breakout snake clock catclock glendy mahjongg  Some useful documents for reference:</description>
	  <mp3></mp3>
	  <youtube_id></youtube_id>
    </item>
    
    <item>
      <title>Creating and Applying 9front Patches (HG Edition)</title>
      <link>https://seh.dev/patches/</link>
      <pubDate>Fri, 07 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://seh.dev/patches/</guid>
      <description>Creating and Applying 9front Patches (HG Edition) Creating To create a patch we first pull 9front&amp;rsquo;s hg repo and bind our files into place:
sysupdate bind -a /dist/plan9front / cd / In this example we&amp;rsquo;re making a patch for rio, any combination of folders should work:
bind $home/src/rio /sys/src/cmd/rio To get the latest commit:
hg log | sed 5q A first log output example might be:
changeset: 6705:eecec6d3b341 user: cinap_lenrek@felloff.net date: Mon Sep 03 20:54:26 2018 +0200 summary: vt: fix plumbsel(), snarfsel() The commit hash we&amp;rsquo;re looking for is eecec6d3b341 and we can use it as follows to make the diff file:</description>
	  <mp3></mp3>
	  <youtube_id></youtube_id>
    </item>
    
    <item>
      <title>Touring Blit in 2018</title>
      <link>https://seh.dev/blit-tour/</link>
      <pubDate>Wed, 30 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://seh.dev/blit-tour/</guid>
      <description>Touring Blit in 2018 Ever wondered if there was a nice way to get a VAX-grade, semi-authentic, Blit experience?
Good news! While 9front ships with a Blit emulator via games/blit you can also connect to UNIX from GNU/Linux with this handy port and plan9port.
To get a connection going just run the following on your emulator of choice:
blit -t &amp;#39;tcp!papnet.eu!8888&amp;#39; Choose ken as your username.
To start a window manager:</description>
	  <mp3></mp3>
	  <youtube_id></youtube_id>
    </item>
    
    <item>
      <title>DiscordFS —- A Tale of Two Clients</title>
      <link>https://seh.dev/discordfs-thoughts/</link>
      <pubDate>Thu, 24 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://seh.dev/discordfs-thoughts/</guid>
      <description>DiscordFS &amp;ndash; A Tale of Two Clients Around a year ago I worked on my first attempt at a Discord client that would build and function on 9front. Since then the landscape hasn&amp;rsquo;t changed much and neither has the client. It works well enough for my needs and the two or so other people who use it. Since then however, the number of members in the 9fans Discord Server has grown many times its original size.</description>
	  <mp3></mp3>
	  <youtube_id></youtube_id>
    </item>
    
    <item>
      <title>Install Notes for Plan 9 Second Edition</title>
      <link>https://seh.dev/plan9-2e/</link>
      <pubDate>Mon, 19 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://seh.dev/plan9-2e/</guid>
      <description>Install Notes for Plan 9 Second Edition A thanks to aap for providing copies of the floppy images and isos used to perform the test installs. None of this would have been able to happen without you.
Disclaimer: I have not successfully managed to get Plan 9 2e (2e from hereon) installed in qemu or physical hardware. Qemu has had issues due to the fact that I&amp;rsquo;m unfamiliar with configuring IDE in qemu.</description>
	  <mp3></mp3>
	  <youtube_id></youtube_id>
    </item>
    
    <item>
      <title>Using Plan9Port Mkfiles</title>
      <link>https://seh.dev/p9p-mkfiles/</link>
      <pubDate>Sat, 03 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://seh.dev/p9p-mkfiles/</guid>
      <description>Using Plan9Port Mkfiles Recently I decided to play with the idea of porting Nemo&amp;rsquo;s semfs (from Ch13 of his book) to *nix as a learning exercise.
As a goal I wanted to change as little of the original code as possible. Even with the plan9port 9c/9l bindings however, some portions of the source (unnamed struct members, mostly) did not build and required changing.
A notable point of change was the mkfile for semfs, originally using the mkone file, I needed to find the equivalent mkfile in plan9port.</description>
	  <mp3></mp3>
	  <youtube_id></youtube_id>
    </item>
    
  </channel>
</rss>
